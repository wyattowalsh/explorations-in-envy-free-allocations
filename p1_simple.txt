
model p1_simple.mod;
##SETS##
set people;
set objects;


### PARAMETERS ###
param VALUE {people, objects};


### VARIABLES ###
var X {people, objects} binary;
var Y;
var Envy{people} <= 1;
var personVALUE{people};
var sign{people} binary;

### OBJECTIVE FUNCTION ###
minimize MaxEnvy: Y;

### ASSIGNED TO ONE PERSON ###
subject to assignment {object in objects}:
	sum{person in people} (X[person,object]) = 1;

subject to	getValue {person in people}:
	personVALUE[person] =
	sum{object in objects} (X[person,object]*VALUE[person,object]);

subject to	defEnvy {person in people}:
 	Envy[person] = ((1-personVALUE[person])-personVALUE[person]);
 	
subject to	maxEachEnvy {person in people}:
	Y >= Envy[person];

# subject to determineSign {person in people}:
# 	sign[person] >= ((1-personVALUE[person])-personVALUE[person])

data p1_simple.dat;

p1_simple.dat, line 5 (offset 55):
	numObjects is not a param (or var or constraint)
context:  param  >>> numObjects <<<  = 2;

p1_simple.dat, line 7 (offset 78):
	numPeople is not a param (or var or constraint)
context:  param  >>> numPeople <<<  := 2; 

p1_simple.dat, line 9 (offset 102):
	v is not a param (or var or constraint)
context:  param  >>> v <<<  :=

solve;
ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people}:
	totIndValue[person] =  
	sum{object in objects} (X[person,object] * v[person,object]);

# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	 p[person, otherPerson] >= totIndValue[otherPerson] - totIndValue[person];

p1.mod, line 52 (offset 1611):
	p needs 1 subscript, not 2
context:  p[person,  >>> otherPerson] <<<  >= totIndValue[otherPerson] - totIndValue[person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people}:
	pMin >= p[person];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;
ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people}:
	totIndValue[person] =  
	sum{object in objects} (X[person,object] * v[person,object]);

# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	 p[person, otherPerson] >= totIndValue[otherPerson] - totIndValue[person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people}:
	pMin >= p[person];

p1.mod, line 56 (offset 1782):
	p needs 2 subscripts, not 1
context:  pMin >=  >>> p[person] <<< ;

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;
ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people}:
	totIndValue[person] =  
	sum{object in objects} (X[person,object] * v[person,object]);

# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	 p[person, otherPerson] >= totIndValue[otherPerson] - totIndValue[person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
37 variables:
	20 binary variables
	17 linear variables
34 constraints, all linear; 123 nonzeros
	10 equality constraints
	24 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal (non-)integer solution; objective 0.028109999
25 MIP simplex iterations
0 branch-and-bound nodes
4 integer variables rounded (maxerr = 3.97498e-09).
Assigning integrality = 2e-09 might help.
Currently integrality = 1e-05.

display _varname, _var;:        _varname        _var      :=
1    pMin               0.02811
2    'X[1,1]'           0
3    'X[1,2]'           0
4    'X[1,3]'           1
5    'X[1,4]'           0
6    'X[1,5]'           1
7    'X[2,1]'           0
8    'X[2,2]'           0
9    'X[2,3]'           0
10   'X[2,4]'           1
11   'X[2,5]'           0
12   'X[3,1]'           0
13   'X[3,2]'           1
14   'X[3,3]'           0
15   'X[3,4]'           0
16   'X[3,5]'           0
17   'X[4,1]'           1
18   'X[4,2]'           0
19   'X[4,3]'           0
20   'X[4,4]'           0
21   'X[4,5]'           0
22   'p[1,1]'           0
23   'p[1,2]'           0.02811
24   'p[1,3]'           0.02811
25   'p[1,4]'           0.02811
26   'p[2,1]'           0.02811
27   'p[2,2]'           0
28   'p[2,3]'           0.02811
29   'p[2,4]'           0.02811
30   'p[3,1]'           0.02811
31   'p[3,2]'           0.02811
32   'p[3,3]'           0
33   'p[3,4]'           0.02811
34   'p[4,1]'           0.02811
35   'p[4,2]'           0.02811
36   'p[4,3]'           0.02811
37   'p[4,4]'           0
38   'totIndValue[1]'   0.11667
39   'totIndValue[2]'   0.12245
40   'totIndValue[3]'   0.11628
41   'totIndValue[4]'   0.09434
;

ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherperson, object]);

p1.mod, line 45 (offset 1401):
	otherperson is undefined
context:  sum {object in objects} (v[person, object] * X[otherperson,  >>> object] <<< );
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] >= totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;
ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] >= totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
49 variables:
	20 binary variables
	29 linear variables
46 constraints, all linear; 192 nonzeros
	22 equality constraints
	24 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal integer solution; objective 0.04349
22 MIP simplex iterations
0 branch-and-bound nodes

display _varname, _var;:         _varname         _var      :=
1    pMin                 0.04349
2    'X[1,1]'             1
3    'X[1,2]'             0
4    'X[1,3]'             0
5    'X[1,4]'             0
6    'X[1,5]'             0
7    'X[2,1]'             0
8    'X[2,2]'             1
9    'X[2,3]'             0
10   'X[2,4]'             0
11   'X[2,5]'             0
12   'X[3,1]'             0
13   'X[3,2]'             0
14   'X[3,3]'             1
15   'X[3,4]'             0
16   'X[3,5]'             1
17   'X[4,1]'             0
18   'X[4,2]'             0
19   'X[4,3]'             0
20   'X[4,4]'             1
21   'X[4,5]'             0
22   'p[1,1]'             0
23   'p[1,2]'             0.04349
24   'p[1,3]'             0.04349
25   'p[1,4]'             0.04349
26   'p[2,1]'             0.04349
27   'p[2,2]'             0
28   'p[2,3]'             0.04349
29   'p[2,4]'             0.04349
30   'p[3,1]'             0.04349
31   'p[3,2]'             0.04349
32   'p[3,3]'             0
33   'p[3,4]'             0.04349
34   'p[4,1]'             0.04349
35   'p[4,2]'             0.04349
36   'p[4,3]'             0.04349
37   'p[4,4]'             0
38   'totIndValue[1,1]'   0.5
39   'totIndValue[1,2]'   0.33333
40   'totIndValue[1,3]'   0.11667
41   'totIndValue[1,4]'   0.05
42   'totIndValue[2,1]'   0.20408
43   'totIndValue[2,2]'   0.40816
44   'totIndValue[2,3]'   0.2653
45   'totIndValue[2,4]'   0.12245
46   'totIndValue[3,1]'   0.34884
47   'totIndValue[3,2]'   0.11628
48   'totIndValue[3,3]'   0.30535
49   'totIndValue[3,4]'   0.23558
50   'totIndValue[4,1]'   0.09434
51   'totIndValue[4,2]'   0.28302
52   'totIndValue[4,3]'   0.24528
53   'totIndValue[4,4]'   0.37736
;

ampl: include p2.run;

reset; 

model p2.mod;
##SETS##
set people;
set objects;
### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;



### VARIABLES ###
var pMax >= 0, <= 1;
var totIndValue{people, people} >= 0, <= 1;
var p{people, people} <= 1, >= 0;
var vMax {people, people} <= 1, >= 0; 
var X{people, objects} binary;

minimize p2: pMax; #0.0934 0.0404

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable.
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);

maxP {person in people, otherPerson in people: otherPerson<>person}:
	pMax >= p[person, otherPerson];

findP {person in people, otherPerson in people: otherPerson <> person}: #, otherPerson in people: otherPerson <> person
	 p[person,  otherPerson] >=  totIndValue[person, otherPerson] - (vMax[person, otherPerson]) - totIndValue[person];

p2.mod, line 40 (offset 1365):
	totIndValue needs 2 subscripts, not 1
context:  p[person,  otherPerson] >=  totIndValue[person, otherPerson] - (vMax[person, otherPerson]) -  >>> totIndValue[person] <<< ;

# findOtherValue {person in people}:
# 	totOtherValue [person]

findVMax {person in people, otherPerson in people, object in objects: person <> otherPerson}:
	vMax[person, otherPerson] >= (v[otherPerson, object] * (X[otherPerson,object]));





data p1_simple.dat; 

solve;
ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] >= totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
49 variables:
	20 binary variables
	29 linear variables
46 constraints, all linear; 192 nonzeros
	22 equality constraints
	24 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal integer solution; objective 0.04349
22 MIP simplex iterations
0 branch-and-bound nodes

display _varname, _var;:         _varname         _var      :=
1    pMin                 0.04349
2    'X[1,1]'             1
3    'X[1,2]'             0
4    'X[1,3]'             0
5    'X[1,4]'             0
6    'X[1,5]'             0
7    'X[2,1]'             0
8    'X[2,2]'             1
9    'X[2,3]'             0
10   'X[2,4]'             0
11   'X[2,5]'             0
12   'X[3,1]'             0
13   'X[3,2]'             0
14   'X[3,3]'             1
15   'X[3,4]'             0
16   'X[3,5]'             1
17   'X[4,1]'             0
18   'X[4,2]'             0
19   'X[4,3]'             0
20   'X[4,4]'             1
21   'X[4,5]'             0
22   'p[1,1]'             0
23   'p[1,2]'             0.04349
24   'p[1,3]'             0.04349
25   'p[1,4]'             0.04349
26   'p[2,1]'             0.04349
27   'p[2,2]'             0
28   'p[2,3]'             0.04349
29   'p[2,4]'             0.04349
30   'p[3,1]'             0.04349
31   'p[3,2]'             0.04349
32   'p[3,3]'             0
33   'p[3,4]'             0.04349
34   'p[4,1]'             0.04349
35   'p[4,2]'             0.04349
36   'p[4,3]'             0.04349
37   'p[4,4]'             0
38   'totIndValue[1,1]'   0.5
39   'totIndValue[1,2]'   0.33333
40   'totIndValue[1,3]'   0.11667
41   'totIndValue[1,4]'   0.05
42   'totIndValue[2,1]'   0.20408
43   'totIndValue[2,2]'   0.40816
44   'totIndValue[2,3]'   0.2653
45   'totIndValue[2,4]'   0.12245
46   'totIndValue[3,1]'   0.34884
47   'totIndValue[3,2]'   0.11628
48   'totIndValue[3,3]'   0.30535
49   'totIndValue[3,4]'   0.23558
50   'totIndValue[4,1]'   0.09434
51   'totIndValue[4,2]'   0.28302
52   'totIndValue[4,3]'   0.24528
53   'totIndValue[4,4]'   0.37736
;

ampl: display {person1 in people, person2 in people} totIndValue[person1,person2] - totIndValue[person1, person2];
totIndValue[person1,person2] - totIndValue[person1,person2] :=
1 1   0
1 2   0
1 3   0
1 4   0
2 1   0
2 2   0
2 3   0
2 4   0
3 1   0
3 2   0
3 3   0
3 4   0
4 1   0
4 2   0
4 3   0
4 4   0
;

ampl: display {person1 in people, person2 in people} totIndValue[person1,person2] - totIndValue[person1, person1];
totIndValue[person1,person2] - totIndValue[person1,person1] :=
1 1    0
1 2   -0.16667
1 3   -0.38333
1 4   -0.45
2 1   -0.20408
2 2    0
2 3   -0.14286
2 4   -0.28571
3 1    0.04349
3 2   -0.18907
3 3    0
3 4   -0.06977
4 1   -0.28302
4 2   -0.09434
4 3   -0.13208
4 4    0
;

ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] = totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
49 variables:
	20 binary variables
	29 linear variables
46 constraints, all linear; 192 nonzeros
	34 equality constraints
	12 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal integer solution; objective 0.5
0 MIP simplex iterations
0 branch-and-bound nodes

display _varname, _var;:         _varname         _var      :=
1    pMin                 0.5
2    'X[1,1]'             0
3    'X[1,2]'             0
4    'X[1,3]'             1
5    'X[1,4]'             0
6    'X[1,5]'             0
7    'X[2,1]'             0
8    'X[2,2]'             0
9    'X[2,3]'             0
10   'X[2,4]'             1
11   'X[2,5]'             1
12   'X[3,1]'             0
13   'X[3,2]'             1
14   'X[3,3]'             0
15   'X[3,4]'             0
16   'X[3,5]'             0
17   'X[4,1]'             1
18   'X[4,2]'             0
19   'X[4,3]'             0
20   'X[4,4]'             0
21   'X[4,5]'             0
22   'p[1,1]'             0
23   'p[1,2]'             0.16667
24   'p[1,3]'             0.33333
25   'p[1,4]'             0.5
26   'p[2,1]'             0.02041
27   'p[2,2]'             0
28   'p[2,3]'             0.22449
29   'p[2,4]'             0.02041
30   'p[3,1]'             0.1193
31   'p[3,2]'             0.18907
32   'p[3,3]'             0
33   'p[3,4]'             0.23256
34   'p[4,1]'             0.0566
35   'p[4,2]'             0.37736
36   'p[4,3]'             0.18868
37   'p[4,4]'             0
38   'totIndValue[1,1]'   0
39   'totIndValue[1,2]'   0.16667
40   'totIndValue[1,3]'   0.33333
41   'totIndValue[1,4]'   0.5
42   'totIndValue[2,1]'   0.20408
43   'totIndValue[2,2]'   0.18367
44   'totIndValue[2,3]'   0.40816
45   'totIndValue[2,4]'   0.20408
46   'totIndValue[3,1]'   0.23558
47   'totIndValue[3,2]'   0.30535
48   'totIndValue[3,3]'   0.11628
49   'totIndValue[3,4]'   0.34884
50   'totIndValue[4,1]'   0.15094
51   'totIndValue[4,2]'   0.4717
52   'totIndValue[4,3]'   0.28302
53   'totIndValue[4,4]'   0.09434
;

ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1, >= 0; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] = totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
49 variables:
	20 binary variables
	29 linear variables
46 constraints, all linear; 192 nonzeros
	34 equality constraints
	12 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal integer solution; objective 0.5
0 MIP simplex iterations
0 branch-and-bound nodes

display _varname, _var;:         _varname         _var      :=
1    pMin                 0.5
2    'X[1,1]'             0
3    'X[1,2]'             0
4    'X[1,3]'             1
5    'X[1,4]'             0
6    'X[1,5]'             0
7    'X[2,1]'             0
8    'X[2,2]'             0
9    'X[2,3]'             0
10   'X[2,4]'             1
11   'X[2,5]'             1
12   'X[3,1]'             0
13   'X[3,2]'             1
14   'X[3,3]'             0
15   'X[3,4]'             0
16   'X[3,5]'             0
17   'X[4,1]'             1
18   'X[4,2]'             0
19   'X[4,3]'             0
20   'X[4,4]'             0
21   'X[4,5]'             0
22   'p[1,1]'             0
23   'p[1,2]'             0.16667
24   'p[1,3]'             0.33333
25   'p[1,4]'             0.5
26   'p[2,1]'             0.02041
27   'p[2,2]'             0
28   'p[2,3]'             0.22449
29   'p[2,4]'             0.02041
30   'p[3,1]'             0.1193
31   'p[3,2]'             0.18907
32   'p[3,3]'             0
33   'p[3,4]'             0.23256
34   'p[4,1]'             0.0566
35   'p[4,2]'             0.37736
36   'p[4,3]'             0.18868
37   'p[4,4]'             0
38   'totIndValue[1,1]'   0
39   'totIndValue[1,2]'   0.16667
40   'totIndValue[1,3]'   0.33333
41   'totIndValue[1,4]'   0.5
42   'totIndValue[2,1]'   0.20408
43   'totIndValue[2,2]'   0.18367
44   'totIndValue[2,3]'   0.40816
45   'totIndValue[2,4]'   0.20408
46   'totIndValue[3,1]'   0.23558
47   'totIndValue[3,2]'   0.30535
48   'totIndValue[3,3]'   0.11628
49   'totIndValue[3,4]'   0.34884
50   'totIndValue[4,1]'   0.15094
51   'totIndValue[4,2]'   0.4717
52   'totIndValue[4,3]'   0.28302
53   'totIndValue[4,4]'   0.09434
;

ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] >= totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
49 variables:
	20 binary variables
	29 linear variables
46 constraints, all linear; 192 nonzeros
	22 equality constraints
	24 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal integer solution; objective 0.04349
22 MIP simplex iterations
0 branch-and-bound nodes

display _varname, _var;:         _varname         _var      :=
1    pMin                 0.04349
2    'X[1,1]'             1
3    'X[1,2]'             0
4    'X[1,3]'             0
5    'X[1,4]'             0
6    'X[1,5]'             0
7    'X[2,1]'             0
8    'X[2,2]'             1
9    'X[2,3]'             0
10   'X[2,4]'             0
11   'X[2,5]'             0
12   'X[3,1]'             0
13   'X[3,2]'             0
14   'X[3,3]'             1
15   'X[3,4]'             0
16   'X[3,5]'             1
17   'X[4,1]'             0
18   'X[4,2]'             0
19   'X[4,3]'             0
20   'X[4,4]'             1
21   'X[4,5]'             0
22   'p[1,1]'             0
23   'p[1,2]'             0.04349
24   'p[1,3]'             0.04349
25   'p[1,4]'             0.04349
26   'p[2,1]'             0.04349
27   'p[2,2]'             0
28   'p[2,3]'             0.04349
29   'p[2,4]'             0.04349
30   'p[3,1]'             0.04349
31   'p[3,2]'             0.04349
32   'p[3,3]'             0
33   'p[3,4]'             0.04349
34   'p[4,1]'             0.04349
35   'p[4,2]'             0.04349
36   'p[4,3]'             0.04349
37   'p[4,4]'             0
38   'totIndValue[1,1]'   0.5
39   'totIndValue[1,2]'   0.33333
40   'totIndValue[1,3]'   0.11667
41   'totIndValue[1,4]'   0.05
42   'totIndValue[2,1]'   0.20408
43   'totIndValue[2,2]'   0.40816
44   'totIndValue[2,3]'   0.2653
45   'totIndValue[2,4]'   0.12245
46   'totIndValue[3,1]'   0.34884
47   'totIndValue[3,2]'   0.11628
48   'totIndValue[3,3]'   0.30535
49   'totIndValue[3,4]'   0.23558
50   'totIndValue[4,1]'   0.09434
51   'totIndValue[4,2]'   0.28302
52   'totIndValue[4,3]'   0.24528
53   'totIndValue[4,4]'   0.37736
;

ampl: include p1_larger.run;
reset; 


model p1.mod;
##SETS##
set people;
set objects;

### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;
### VARIABLES ### 

# variable for max p of p-envy-free present in the set people
var pMin <= 1, >= 0;

# indicator variable whether person i is assigned object j
var X{people, objects} binary; 

# helper variable for p of p-envy-free for each person in people
## defined as greater than or equal to 0; Also rows sum to 1, thus <= 1
var p{people, people} <= 1; 

# var adjP{people} <=1;
# helper variable for the value of a certain person's allocated value.
var totIndValue{people, people} >= 0, <= 1;

### OBJECTIVE FUNCTION ###
minimize pEnvyFree: pMin;

### CONSTRAINTS	###
s.t.

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable. 
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);
 
# intermediary constraint to determine each person's p level of 
# envy-freeness
## This is determined by the inequality 
## portfolio value >= portfolio value complement - p
findP {person in people, otherPerson in people: otherPerson <> person}:
	p[person, otherPerson] = totIndValue[person,otherPerson] - totIndValue[person, person];
 # 
# detPos[person] - detPos[person] * 2 * totIndValue[person];
maxP {person in people, otherPerson in people: otherPerson <> person}:
	pMin >= p[person, otherPerson];

# adjustP {person in people}:
# 	adjP[person] <= p[person] - p[perse] totIndValue[person];


# findDetNegUpper {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) - 
# 	(100 * detNeg[person]) <= 0.5;

# findDetNeglower {person in people}:
# 	sum{object in objects} (X[person,object] * v[person,object]) + (100 * detPos[person]) >= 0.5;

# sumDetNeg {person in people}:
# 	detPos[person] + detNeg[person] = 1;



data p1_larger.dat; 

solve;

Presolve eliminates 0 constraints and 4 variables.
Adjusted problem:
49 variables:
	20 binary variables
	29 linear variables
46 constraints, all linear; 192 nonzeros
	34 equality constraints
	12 inequality constraints
1 linear objective; 1 nonzero.

CPLEX 12.9.0.0: optimal integer solution; objective 0.04349
22 MIP simplex iterations
0 branch-and-bound nodes

display _varname, _var;:         _varname          _var      :=
1    pMin                  0.04349
2    'X[1,1]'              1
3    'X[1,2]'              0
4    'X[1,3]'              0
5    'X[1,4]'              0
6    'X[1,5]'              0
7    'X[2,1]'              0
8    'X[2,2]'              1
9    'X[2,3]'              0
10   'X[2,4]'              0
11   'X[2,5]'              0
12   'X[3,1]'              0
13   'X[3,2]'              0
14   'X[3,3]'              1
15   'X[3,4]'              0
16   'X[3,5]'              1
17   'X[4,1]'              0
18   'X[4,2]'              0
19   'X[4,3]'              0
20   'X[4,4]'              1
21   'X[4,5]'              0
22   'p[1,1]'              0
23   'p[1,2]'             -0.16667
24   'p[1,3]'             -0.38333
25   'p[1,4]'             -0.45
26   'p[2,1]'             -0.20408
27   'p[2,2]'              0
28   'p[2,3]'             -0.14286
29   'p[2,4]'             -0.28571
30   'p[3,1]'              0.04349
31   'p[3,2]'             -0.18907
32   'p[3,3]'              0
33   'p[3,4]'             -0.06977
34   'p[4,1]'             -0.28302
35   'p[4,2]'             -0.09434
36   'p[4,3]'             -0.13208
37   'p[4,4]'              0
38   'totIndValue[1,1]'    0.5
39   'totIndValue[1,2]'    0.33333
40   'totIndValue[1,3]'    0.11667
41   'totIndValue[1,4]'    0.05
42   'totIndValue[2,1]'    0.20408
43   'totIndValue[2,2]'    0.40816
44   'totIndValue[2,3]'    0.2653
45   'totIndValue[2,4]'    0.12245
46   'totIndValue[3,1]'    0.34884
47   'totIndValue[3,2]'    0.11628
48   'totIndValue[3,3]'    0.30535
49   'totIndValue[3,4]'    0.23558
50   'totIndValue[4,1]'    0.09434
51   'totIndValue[4,2]'    0.28302
52   'totIndValue[4,3]'    0.24528
53   'totIndValue[4,4]'    0.37736
;

ampl: include p2.run;

reset; 

model p2.mod;
##SETS##
set people;
set objects;
### PARAMETERS ###
param v{people, objects};
param numObjects;
param numPeople;



### VARIABLES ###
var pMax >= 0, <= 1;
var totIndValue{people, people} >= 0, <= 1;
var p{people, people} <= 1;
var vMax {people, people} <= 1, >= 0; 
var X{people, objects} binary;

minimize p2: pMax; 

# every item is allocated to some person
## sum of indicators over all people should equal 1 for all objects
allocateAll {object in objects}:
	sum{person in people} (X[person,object]) = 1;

# The total number of chosen objects should be the number of available objects
indivisibleObjects:
	sum{person in people} (sum{object in objects} X[person,object]) = numObjects;

# intermediary constraint to find each person's optimal allocation value
## This is enabled by summing over all objects and filtering using the X
## indicator variable.
findTotIndValue {person in people, otherPerson in people}:
	totIndValue[person, otherPerson] =  
	sum {object in objects} (v[person, object] * X[otherPerson, object]);

maxP {person in people, otherPerson in people: otherPerson<>person}:
	pMax >= p[person, otherPerson];

findP {person in people, otherPerson in people: otherPerson <> person}: #, otherPerson in people: otherPerson <> person
	 p[person,  otherPerson] =  totIndValue[person, otherPerson] - (vMax[person, otherPerson]) - totIndValue[person];

p2.mod, line 40 (offset 1344):
	totIndValue needs 2 subscripts, not 1
context:  p[person,  otherPerson] =  totIndValue[person, otherPerson] - (vMax[person, otherPerson]) -  >>> totIndValue[person] <<< ;

# findOtherValue {person in people}:
# 	totOtherValue [person]

findVMax {person in people, otherPerson in people, object in objects: person <> otherPerson}:
	vMax[person, otherPerson] >= (v[otherPerson, object] * (X[otherPerson,object]));





data p1_simple.dat; 

solve;
ampl: include p2.run;

reset; 
